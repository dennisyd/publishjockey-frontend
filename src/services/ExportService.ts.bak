// src/services/ExportService.ts
import { ExportSettings } from "../components/ExportModal"

import { MarkdownFormatter } from "./MarkdownFormatter"
import { FormatAdapter } from "./FormatAdapter"
import { ValidationService } from "./ValidationService"
import tokenManager from "../utils/tokenManager"
import { exportHttp } from "./exportHttp"
import { getLocalizedSectionNames, getLocalizedBookStructure, getLocalizedChapterName } from "../utils/bookStructureLocalization"

import axios from "axios"

// ============== Types ==============
interface Section {
  id: string
  title: string
  content: string
  level: number
  matter?: "front" | "main" | "back"
}

interface Project {
  id: string
  title: string
  author?: string
  subtitle?: string
  sections: Section[]
}

interface ExportFormat {
  format: "pdf" | "epub" | "html" | "docx" | string
}

// ============== Helpers ==============
function getCurrentLanguage(): string {
  const storedLang = localStorage.getItem("i18nextLng")
  if (storedLang) return storedLang.split("-")[0]
  const browserLang = navigator.language || (navigator.languages?.[0] ?? "en")
  return browserLang.split("-")[0]
}

function ensureMatter(id: string): "front" | "main" | "back" {
  if (id.startsWith("front:")) return "front"
  if (id.startsWith("main:")) return "main"
  if (id.startsWith("back:")) return "back"
  return "main"
}

// ============== Service ==============
/**
 * Service for handling document exports with different formats
 */
export class ExportService {
  /** Escape special characters that break LaTeX headings (conservative: only &) */
  private static sanitizeLatexHeading(title?: string): string | undefined {
    if (!title) return title
    return title.replace(/&/g, "\\&")
  }

  /** Escape ampersands on markdown heading lines only (for PDF builds). */
  private static sanitizeAmpersandInMarkdownHeadings(markdown: string): string {
    const lines = markdown.split(/\r?\n/)
    for (let i = 0; i < lines.length; i++) {
      if (/^\s{0,3}#{1,6}\s/.test(lines[i])) {
        lines[i] = lines[i].replace(/&/g, "\\&")
      }
    }
    return lines.join("\n")
  }

  /**
   * Exports a project to the specified format using the provided export settings
   */
  public static async exportProject(
    project: Project,
    settings: ExportSettings,
  ): Promise<string> {
    console.log("ExportProject called with settings:", settings)

    const exportFormat = settings.format === "docx" ? "word" : settings.format
    if ((window as any).exportTiming) {
      ;(window as any).exportTiming.startExport(exportFormat, project.title)
    }

    // ---------- Basic validation ----------
    if (!project || !project.title) {
      throw new Error("Invalid project data. Please ensure the project has a title.")
    }
    if (!Array.isArray(project.sections) || project.sections.length === 0) {
      throw new Error("No content to export. Please add content to at least one section.")
    }

    // ---------- Normalize sections with matter ----------
    const sectionsWithMatter: Section[] = project.sections.map((s) => ({
      ...s,
      matter: ensureMatter(s.id),
    }))

    // ---------- Centralized chapter formatting ----------
    const formattedSections = MarkdownFormatter.formatSectionsForExport(
      sectionsWithMatter as Array<{ id: string; title: string; content: string; matter: string; level?: number }>,
      {
        useChapterPrefix: settings.useChapterPrefix !== false,
        chapterLabelFormat: settings.chapterLabelFormat || "number",
      },
    )

    // Ensure level property exists (default to 0)
    const sectionsWithLevel = formattedSections.map((s) => ({
      ...s,
      level: (s as any).level || 0,
    }))

    // ---------- Validate before export ----------
    this.validateSectionsBeforeExport(
      sectionsWithLevel.map((s) => ({
        id: s.id,
        title: s.title,
        content: s.content,
        matter: s.matter || "main",
      })),
    )

    // ---------- Adapt content for target format ----------
    const adaptedSections = sectionsWithLevel.map((section) => ({
      ...section,
      content: FormatAdapter.adaptForExport(section.content, settings.format),
    }))

    // ---------- Title page handling ----------
    const titlePageSection = this.findTitlePageSection(adaptedSections)

    let fallbackTitlePage: string | undefined
    if (settings.includeTitlePage && !titlePageSection) {
      fallbackTitlePage = `# ${project.title}\n\n`
      if (project.subtitle) fallbackTitlePage += `## ${project.subtitle}\n\n`
      if (project.author) fallbackTitlePage += `By ${project.author}\n\n`
    }

    // ---------- Language ----------
    const currentLanguage = settings.language || getCurrentLanguage()
    console.log(`Exporting with language: ${currentLanguage}`)

    // ---------- Build payload ----------
    const normalizedFormat =
      settings.format === "docx" ? "docx" : settings.format // keep original for endpoint
    const forPdf = normalizedFormat === "pdf"

    const payload = {
      sections: adaptedSections.map((s) => {
        const matter = s.matter === "front" || s.matter === "main" || s.matter === "back" ? s.matter : "main"
        let content = s.content || ""
        if (forPdf) content = ExportService.sanitizeAmpersandInMarkdownHeadings(content)

        const sanitizedTitle = forPdf ? ExportService.sanitizeLatexHeading(s.title) : s.title

        return {
          id: s.id,
          title: sanitizedTitle,
          content,
          matter,
          isTitlePage:
            s.id === "front:Title Page" ||
            s.title?.toLowerCase() === "title page",
        }
      }),
      exportOptions: {
        ...settings,
        language: currentLanguage,
        fontFamily: settings.fontFamily,
        useChapterPrefix: false, // already applied in frontend
        includeTitlePage: !!(titlePageSection || fallbackTitlePage),
        generateTitlePage: false,
        forceTitleFirst: !!titlePageSection,
        metadata: {
          title: project.title,
          author: project.author || "Anonymous",
          subtitle: project.subtitle || "",
          date: new Date().toISOString().split("T")[0],
        },
        titlePageContent: titlePageSection ? titlePageSection.content : fallbackTitlePage,
        includeToc: settings.includeToc,
        tocEnabled: settings.includeToc,
        tocDepth: settings.tocDepth ?? 2,
        frontMatterContinuous: settings.frontMatterContinuous !== false,
      },
      title: project.title,
      author: project.author || "Anonymous",
      subtitle: project.subtitle || "",
    }

    // ---------- Endpoint ----------
    let endpoint = ""
    switch (normalizedFormat) {
      case "pdf":
        endpoint = "/export/pdf"
        break
      case "epub":
        endpoint = "/export/epub"
        break
      case "html":
        endpoint = "/export/html"
        break
      case "docx":
        endpoint = "/export/docx"
        break
      default:
        throw new Error(`Unsupported export format: ${settings.format}`)
    }

    // ---------- Call backend ----------
    try {
      console.log(`Making API call to ${endpoint}`)
      const response = await exportHttp.post(endpoint, payload)

      if (response.status !== 200) {
        throw new Error(
          `Export server returned error ${response.status}: ${JSON.stringify(response.data)}`,
        )
      }

      // Optional server hint to not auto-download
      const noDownload = String(response.headers?.["x-no-download"] ?? "").toLowerCase() === "true"
      if (noDownload) {
        console.log("X-No-Download header detected; skipping download.")
        return ""
      }

      const responseData = response.data || {}

      // New flow: server returns a fileId (+ mimeType, optional fileName)
      if (responseData.fileId && responseData.mimeType) {
        if ((window as any).exportTiming) {
          const exportData = {
            blob: null as Blob | null,
            format: exportFormat,
            fileName:
              responseData.fileName ||
              `${project.title.replace(/\s+/g, "_").replace(/[^\w-]/g, "")}.${
                exportFormat === "word" ? "docx" : exportFormat
              }`,
            fileId: responseData.fileId,
          }
          ;(window as any).exportTiming.finishExportWithBlob(exportData)
        }
        return ""
      }

      // Legacy flow: base64 payload
      if (responseData.base64Data && responseData.mimeType) {
        const binaryString = atob(responseData.base64Data)
        const bytes = new Uint8Array(binaryString.length)
        for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i)
        const blob = new Blob([bytes], { type: responseData.mimeType })

        const fileId = responseData.fileId || `${project.id || "export"}_${Date.now()}`
        if ((window as any).exportTiming) {
          const exportData = {
            blob,
            format: exportFormat,
            fileName: `${
              project.title.replace(/\s+/g, "_").replace(/[^\w-]/g, "")
            }.${exportFormat === "word" ? "docx" : exportFormat}`,
            fileId,
          }
          ;(window as any).exportTiming.finishExportWithBlob(exportData)
        }
        return ""
      }

      // If we got here, the shape is unexpected but not an axios/JSON parse error.
      console.warn("Unexpected export response shape:", responseData)
      return ""
    } catch (err) {
      console.error("Error during API call to export backend:", err)
      throw new Error(`Failed to communicate with export server: ${(err as Error).message}`)
    }
  }

  // ---------- Validation ----------
  private static validateSectionsBeforeExport(
    sections: Array<{ id: string; title: string; content: string; matter: string }>,
  ): void {
    let criticalError = false
    const validationMessages: string[] = []

    sections.forEach((section) => {
      const validation = ValidationService.validateSection(section)
      if (!validation.valid) {
        const criticalIssues = validation.issues.filter((i) => i.code === "EMPTY_SECTION")
        if (criticalIssues.length > 0) criticalError = true
        validationMessages.push(
          `Section ${section.id}: ${validation.issues.map((i) => i.message).join(", ")}`,
        )
      }
    })

    if (validationMessages.length > 0) {
      console.warn("Validation warnings before export:", validationMessages)
    }
    if (criticalError) {
      throw new Error("Export validation failed. Some sections have empty content.")
    }
  }

  // ---------- Title page detection ----------
  private static findTitlePageSection(sections: Section[]): Section | null {
    if (!Array.isArray(sections) || sections.length === 0) return null

    const frontTitle = sections.find(
      (s) =>
        (s.id === "front:Title Page" || s.id.toLowerCase().includes("title page")) &&
        s.matter === "front",
    )
    if (frontTitle) return frontTitle

    const byTitle = sections.find(
      (s) => s.title?.toLowerCase() === "title page" || s.title?.toLowerCase().includes("title page"),
    )
    if (byTitle) return byTitle

    const byContent = sections.find(
      (s) =>
        s.content?.toLowerCase().includes("# title page") ||
        s.content?.toLowerCase().includes("\\begin{titlepage}"),
    )
    return byContent || null
  }

  // ---------- (Optional) Utility ----------
  private static getFileExtension(format: ExportFormat): string {
    switch (format.format) {
      case "pdf":
        return "pdf"
      case "epub":
        return "epub"
      case "html":
        return "html"
      case "docx":
        return "docx"
      default:
        return "txt"
    }
  }

  /**
   * Updates the content of a project by ID (for debugging/manual save)
   * NOTE: Uses tokenManager + exportHttp baseURL to avoid undefined API_URL
   */
  public static async updateProjectContent(
    projectId: string,
    content: Record<string, string>,
    token?: string,
  ): Promise<any> {
    const authToken = token || tokenManager.getToken?.() || localStorage.getItem("token")
    if (!authToken) {
      console.error("No auth token provided or found")
      return { error: "No auth token" }
    }

    try {
      // Use the same base URL as exportHttp; assume "/api" is the project API namespace
      const baseURL = (exportHttp.defaults?.baseURL || "").replace(/\/+$/, "")
      const url = `${baseURL}/api/projects/${projectId}`

      const res = await axios.put(
        url,
        { content },
        { headers: { Authorization: `Bearer ${authToken}` } },
      )
      return res.data
    } catch (err) {
      console.error("Manual update failed:", err)
      return { error: err }
    }
  }

  public static async testContentSave(projectId: string, token?: string): Promise<any> {
    const testContent = {
      "front:Title Page": "# Test Title\n\nBy Test Author",
      "main:Chapter 1": "## This is a test chapter\n\nJust testing content saving.",
    }
    return this.updateProjectContent(projectId, testContent, token)
  }
}
